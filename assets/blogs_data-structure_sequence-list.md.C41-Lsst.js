import{av as t,p,U as i,q as s,O as h,S as a,aR as r,ah as n,m as k}from"./chunks/framework.7WxYM5Sz.js";const x=JSON.parse('{"title":"顺序表","description":"","frontmatter":{"title":"顺序表","layout":"doc"},"headers":[],"relativePath":"blogs/data-structure/sequence-list.md","filePath":"blogs/data-structure/sequence-list.md","lastUpdated":1698109494000}'),d={name:"blogs/data-structure/sequence-list.md"},c=s("h1",{id:"顺序表",tabindex:"-1"},[a("顺序表 "),s("a",{class:"header-anchor",href:"#顺序表","aria-label":'Permalink to "顺序表"'},"​")],-1),o={style:{display:"flex",gap:"10px"}},u=s("h2",{id:"顺序表定义",tabindex:"-1"},[a("顺序表定义 "),s("a",{class:"header-anchor",href:"#顺序表定义","aria-label":'Permalink to "顺序表定义"'},"​")],-1),g=s("p",null,"线性表的顺序存储又称顺序表。它是用一组地址连续的存储单元依次存储线性表的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。",-1),b=s("p",{message:"",type:"warning",content:"线性表中元素的位序是从1开始的，但数组的下标是从0开始的/"},null,-1),E=r(`<h2 id="静态数组和动态数组的区别" tabindex="-1">静态数组和动态数组的区别 <a class="header-anchor" href="#静态数组和动态数组的区别" aria-label="Permalink to &quot;静态数组和动态数组的区别&quot;">​</a></h2><p>一维数组可以是<strong>静态分配</strong>的，也可以是<strong>动态分配</strong>的。</p><h3 id="静态分配" tabindex="-1">静态分配 <a class="header-anchor" href="#静态分配" aria-label="Permalink to &quot;静态分配&quot;">​</a></h3><p>由于数组大小和空间已经固定，所以一旦空间占满，在加入新的数据就会产生 <strong>数据溢出</strong>，进而导致程序运行崩溃。</p><h3 id="动态分配" tabindex="-1">动态分配 <a class="header-anchor" href="#动态分配" aria-label="Permalink to &quot;动态分配&quot;">​</a></h3><p>存储数组的空间是由程序执行过程通过动态存储分配语句分配的，一旦数据空间沾满，就可以另辟新的一块更大的存储空间，用以代替原来的存储空间，达到扩充空间的目的。</p><h2 id="顺序表空间分配" tabindex="-1">顺序表空间分配 <a class="header-anchor" href="#顺序表空间分配" aria-label="Permalink to &quot;顺序表空间分配&quot;">​</a></h2><div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ElementType</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MaxSize</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 静态空间分配</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ElementType data[MaxSize];</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 定义顺序表元素</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> lenght;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                    // 当前元素长度</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">SeqList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 动态空间分配</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ElementType </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">data;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">             // 定义顺序表元素</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> MaxLen;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                    // 顺序表最大长度</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> lenght;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                    // 当前元素长度</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">SeqList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h2 id="顺序表优点" tabindex="-1">顺序表优点 <a class="header-anchor" href="#顺序表优点" aria-label="Permalink to &quot;顺序表优点&quot;">​</a></h2><ul><li>随机访问，通过首地址和元素位序可快速找到指定元素</li><li>存储密度高，每个节点只存储数据元素</li><li>逻辑上相邻的元素物理上也相邻</li></ul><h2 id="顺序表缺点" tabindex="-1">顺序表缺点 <a class="header-anchor" href="#顺序表缺点" aria-label="Permalink to &quot;顺序表缺点&quot;">​</a></h2><ul><li>插入和删除需要移动大量元素</li><li>需要连续内存空间</li></ul>`,12);function y(m,_,A,D,f,F){const e=n("el-divider"),l=n("el-tag");return k(),p("div",null,[c,i(e),s("div",o,[i(l,null,{default:h(()=>[a("data structure")]),_:1})]),u,g,b,E])}const v=t(d,[["render",y]]);export{x as __pageData,v as default};
